<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Colorado Wildfire Tracker</title>
    <link rel="preconnect" href="https://api.mapbox.com" />
    <link rel="preconnect" href="https://events.mapbox.com" />
    <link rel="stylesheet" href="https://api.mapbox.com/mapbox-gl-js/v3.1.2/mapbox-gl.css" />
    <style>
        :root {
            color-scheme: dark;
            --bg: #030b16;
            --panel-bg: rgba(6, 14, 27, 0.92);
            --panel-border: rgba(255, 255, 255, 0.08);
            --panel-shadow: 0 24px 45px rgba(0, 0, 0, 0.45);
            --accent: #cf4236;
            --text: #f8f9fb;
            --muted: rgba(255, 255, 255, 0.7);
            --chip-bg: rgba(255, 255, 255, 0.04);
            --chip-border: rgba(255, 255, 255, 0.16);
            --panel-max-width: 300px;
            --panel-padding: 16px;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            min-height: 100vh;
            font-family: 'Source Sans Pro', 'Helvetica Neue', Arial, sans-serif;
            background-color: var(--bg);
            color: var(--text);
            -webkit-font-smoothing: antialiased;
        }

        #map {
            position: fixed;
            inset: 0;
            width: 100%;
            height: 100vh;
        }

        .hud {
            position: absolute;
            top: 18px;
            right: 18px;
            width: min(var(--panel-max-width), calc(100% - 36px));
            display: flex;
            flex-direction: column;
            gap: 12px;
            z-index: 5;
            max-height: calc(100vh - 36px);
            overflow-y: auto;
        }

        .panel {
            background: rgba(5, 8, 16, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.04);
            border-radius: 18px;
            padding: var(--panel-padding);
            box-shadow: 0 30px 50px rgba(3, 7, 18, 0.45);
            backdrop-filter: blur(20px);
            container-type: inline-size;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            --font-xs: clamp(0.6rem, 0.54rem + 0.25vw, 0.72rem);
            --font-sm: clamp(0.72rem, 0.65rem + 0.3vw, 0.88rem);
            --font-md: clamp(0.9rem, 0.8rem + 0.35vw, 1.05rem);
            --font-lg: clamp(1.05rem, 0.95rem + 0.45vw, 1.2rem);
        }

        .panel h1,
        .panel h2,
        .panel h3 {
            margin: 0;
            color: var(--text);
            letter-spacing: -0.01em;
        }

        .panel h1 {
            font-size: var(--font-lg);
            line-height: 1.25;
        }

        .panel h2,
        .accordion summary {
            font-size: var(--font-md);
            letter-spacing: 0.02em;
        }

        .panel p {
            margin: 4px 0;
            color: var(--muted);
            font-size: var(--font-sm);
        }

        .panel-header {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 10px;
            margin-bottom: 12px;
        }

        .eyebrow {
            text-transform: uppercase;
            letter-spacing: 0.18em;
            font-size: 0.65rem;
            color: var(--muted);
            margin-bottom: 4px;
        }

        .stat-table {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin-bottom: 10px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            gap: 12px;
        }

        .stat-row .label {
            font-size: var(--font-xs);
            letter-spacing: 0.08em;
            text-transform: uppercase;
            color: var(--muted);
        }

        .stat-row .value {
            font-size: var(--font-md);
            font-weight: 700;
            color: var(--text);
            text-align: right;
        }

        .top-fires ol {
            margin: 12px 0 0;
            padding-left: 20px;
        }

        .top-fires li {
            margin-bottom: 5px;
            line-height: 1.3;
            font-size: var(--font-sm);
            cursor: pointer;
        }

        .top-fires .fire-meta {
            font-size: 0.85rem;
            color: var(--muted);
        }

        .style-toggle {
            display: inline-flex;
            background: rgba(255, 255, 255, 0.06);
            border-radius: 999px;
            padding: 2px;
            border: 1px solid rgba(255, 255, 255, 0.12);
            gap: 4px;
            flex-wrap: wrap;
        }

        .style-toggle button {
            border: none;
            background: rgba(255, 255, 255, 0.08);
            color: var(--muted);
            font-size: var(--font-xs);
            padding: 4px 12px;
            border-radius: 999px;
            cursor: pointer;
            transition: background 0.2s ease, color 0.2s ease;
            white-space: nowrap;
        }

        .style-toggle button.active {
            background: #f8fafc;
            color: #0c1022;
            font-weight: 600;
        }

        #chart-wrapper {
            margin-top: 18px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 14px;
            overflow: hidden;
            background: rgba(255, 255, 255, 0.02);
        }

        #dw-chart {
            width: 100%;
            min-height: 220px;
            border: none;
            display: block;
        }

        #size-filter-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 8px;
            margin-bottom: 12px;
        }

        .chip {
            position: relative;
            display: block;
        }

        .chip input {
            position: absolute;
            opacity: 0;
            pointer-events: none;
        }

        .chip-content {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 8px;
            border: 1px solid var(--chip-border);
            border-radius: 999px;
            background: rgba(255, 255, 255, 0.02);
            font-size: var(--font-sm);
            cursor: pointer;
            transition: border 0.2s ease, background 0.2s ease;
        }

        .chip input:checked + .chip-content {
            border-color: var(--accent);
            background: rgba(207, 66, 54, 0.15);
        }

        .chip-swatch {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        label.select-label {
            display: flex;
            flex-direction: column;
            gap: 6px;
            font-size: var(--font-sm);
            margin-bottom: 12px;
        }

        label.select-label select {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 999px;
            color: var(--text);
            padding: 6px 34px 6px 12px;
            font-size: var(--font-sm);
            appearance: none;
            background-image: linear-gradient(45deg, transparent 50%, var(--muted) 50%), linear-gradient(135deg, var(--muted) 50%, transparent 50%);
            background-position: calc(100% - 18px) calc(50% - 3px), calc(100% - 10px) calc(50% - 3px);
            background-size: 6px 6px, 6px 6px;
            background-repeat: no-repeat;
        }

        .toggle {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            font-size: var(--font-sm);
            cursor: pointer;
        }

        .toggle input {
            width: 42px;
            height: 22px;
        }

        #timeline-panel input[type="range"] {
            width: 100%;
            margin-top: 16px;
        }

        #timeline-label {
            font-weight: 600;
            color: var(--text);
        }

        .timeline-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 14px;
        }
        .accordion {
            padding: 0;
            border-radius: 16px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.03);
            background: rgba(4, 7, 14, 0.55);
            box-shadow: 0 25px 45px rgba(3, 7, 18, 0.3);
            margin-top: 8px;
        }

        .accordion summary {
            list-style: none;
            cursor: pointer;
            padding: var(--panel-padding);
            font-size: var(--font-md);
            font-weight: 700;
            color: var(--text);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(255, 255, 255, 0.03);
            border-bottom: 1px solid rgba(255, 255, 255, 0.06);
        }

        .accordion summary::-webkit-details-marker {
            display: none;
        }

        .accordion .accordion-hint {
            font-size: var(--font-xs);
            color: var(--muted);
            font-weight: 400;
        }

        .accordion-content {
            padding: 0 var(--panel-padding) var(--panel-padding);
        }

        .timeline-status {
            font-size: var(--font-sm);
            color: var(--muted);
            margin-bottom: 8px;
        }

        @container (max-width: 360px) {
            .panel {
                --font-lg: clamp(1rem, 0.95rem + 0.4vw, 1.15rem);
                --font-md: clamp(0.9rem, 0.8rem + 0.35vw, 1rem);
                --font-sm: clamp(0.75rem, 0.7rem + 0.2vw, 0.85rem);
                --font-xs: clamp(0.65rem, 0.6rem + 0.15vw, 0.75rem);
            }
        }

        .timeline-range {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .timeline-range input[type="range"] {
            flex: 1;
        }

        .timeline-footnote {
            font-size: 0.8rem;
            color: var(--muted);
            margin-top: 8px;
        }

        #loading-overlay {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            background: rgba(3, 11, 22, 0.88);
            color: var(--text);
            z-index: 10;
        }

        #loading-overlay.is-hidden {
            display: none;
        }

        #error-banner {
            position: absolute;
            top: 16px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(207, 66, 54, 0.95);
            color: #fff;
            padding: 10px 18px;
            border-radius: 999px;
            font-size: 0.9rem;
            border: 1px solid rgba(255, 255, 255, 0.2);
            z-index: 6;
        }

        #last-update {
            position: absolute;
            bottom: 16px;
            left: 16px;
            background: rgba(0, 0, 0, 0.65);
            color: #fff;
            padding: 6px 12px;
            border-radius: 999px;
            font-size: 0.8rem;
            letter-spacing: 0.04em;
            z-index: 5;
        }

        .mapboxgl-popup-content {
            background: rgba(5, 8, 16, 0.4);
            border-radius: 14px;
            border: 1px solid rgba(255, 255, 255, 0.06);
            color: var(--text);
            padding: 10px 14px;
            backdrop-filter: blur(14px);
        }

        .mapboxgl-popup-close-button {
            color: #f8fafc;
            font-size: 18px;
            width: 26px;
            height: 26px;
            line-height: 24px;
            background: transparent;
            border: none;
            cursor: pointer;
            text-shadow: 0 0 4px rgba(0, 0, 0, 0.5);
        }

        .mapboxgl-popup-close-button:hover {
            background: rgba(248, 250, 252, 0.1);
        }

        .mapboxgl-popup-tip {
            border-top-color: rgba(5, 8, 16, 0.4) !important;
            border-bottom-color: rgba(5, 8, 16, 0.4) !important;
        }

        .popup h3 {
            margin: 0 0 1px;
            font-size: var(--font-md);
            line-height: 1.1;
        }

        .popup-metric {
            margin: 0;
            font-weight: 600;
            font-size: var(--font-md);
            line-height: 1.2;
        }

        .popup-meta {
            margin: 0;
            font-size: var(--font-sm);
            color: var(--muted);
            line-height: 1.2;
        }

        .popup-note {
            margin: 6px 0 0 0;
            padding-top: 6px;
            font-size: var(--font-xs);
            color: var(--muted);
            font-style: italic;
            border-top: 1px solid rgba(255,255,255,0.15);
            line-height: 1.2;
        }

        .popup-source {
            margin: 6px 0 0 0;
            font-size: var(--font-xs);
            color: var(--muted);
            line-height: 1.2;
        }

        .popup-source a {
            color: #7cb3ff;
            text-decoration: none;
        }

        .popup-source a:hover {
            text-decoration: underline;
        }

        @media (max-width: 1100px) {
            .hud {
                width: min(320px, calc(100% - 28px));
            }
        }

        @media (max-width: 720px) {
            :root {
                --panel-max-width: 100%;
                --panel-padding: 14px;
            }

            .hud {
                position: relative;
                width: 100%;
                right: auto;
                top: auto;
                padding: 12px;
                gap: 12px;
            }

            .panel {
                border-radius: 14px;
            }

            .panel h1 {
                font-size: 1.4rem;
                line-height: 1.2;
            }

            .panel h2 {
                font-size: 1.05rem;
            }

            .panel p,
            .chip-content,
            label.select-label {
                font-size: 0.8rem;
            }

            .metric .label {
                font-size: 0.65rem;
            }

            .metric .value {
                font-size: 1.3rem;
            }

            .panel-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }

            .statewide-metrics {
                grid-template-columns: repeat(2, minmax(0, 1fr));
                gap: 8px;
            }

            #size-filter-container {
                display: flex;
                flex-wrap: wrap;
            }

            .chip {
                flex: 1 1 calc(50% - 6px);
            }

            .chip-content {
                font-size: 0.82rem;
                padding: 7px 9px;
            }

            label.select-label select {
                font-size: 0.85rem;
                padding: 7px 10px;
            }

            #timeline-panel input[type='range'] {
                margin-top: 10px;
            }
        }

        @media (max-width: 540px) {
            #legend-panel,
            #timeline-panel {
                display: none;
            }

            .panel {
                padding: 12px 14px;
            }

            .hud {
                gap: 10px;
            }

            .statewide-metrics {
                gap: 6px;
            }

            .metric {
                padding: 10px;
            }

            .panel h1 {
                font-size: 1.25rem;
            }

            .panel h2 {
                font-size: 1rem;
            }
        }

        @media (max-width: 980px) {
            #map {
                position: relative;
                height: 60vh;
            }

            #last-update {
                position: relative;
                bottom: auto;
                left: auto;
                margin: 12px 0 0 16px;
            }

            #error-banner {
                top: auto;
                bottom: 16px;
            }
        }
    </style>
</head>

<body data-mapbox-token="pk.eyJ1IjoiZXZud2xnIiwiYSI6ImNtaWx6YnBxMzF1YnozY29zaXQ4Mnh1Y2MifQ.WSCifQb8GzrWHhA4PyWa-A" data-datawrapper-chart="" data-top-fires="5">
    <div id="map" role="presentation"></div>
    <div id="loading-overlay" role="status" aria-live="polite">Loading wildfire data…</div>
    <div id="error-banner" role="alert" hidden></div>
    <div id="last-update" aria-live="polite"></div>

    <div class="hud" aria-live="polite">
        <section id="stats-panel" class="panel">
            <div class="panel-header">
                <h1>Colorado wildfire snapshot</h1>
                <div class="style-toggle" role="group" aria-label="Basemap style">
                    <button type="button" data-style="terrain" class="active">Terrain</button>
                    <button type="button" data-style="satellite">Satellite</button>
                </div>
            </div>

            <div class="stat-table" role="table">
                <div class="stat-row" role="row">
                    <span class="label" role="cell">Active fires</span>
                    <span class="value" id="metric-fires" role="cell">--</span>
                </div>
                <div class="stat-row" role="row">
                    <span class="label" role="cell">Acres burning</span>
                    <span class="value" id="metric-acres" role="cell">--</span>
                </div>
                <div class="stat-row" role="row">
                    <span class="label" role="cell">Avg containment</span>
                    <span class="value" id="metric-containment" role="cell">--</span>
                </div>
            </div>

            <div class="top-fires">
                <h2>Largest active fires</h2>
                <ol id="top-fires-list"></ol>
            </div>

            <div id="chart-wrapper" class="chart-wrapper" hidden>
                <iframe id="dw-chart" title="Year-to-date acres burned" scrolling="no" loading="lazy"></iframe>
            </div>
        </section>

        <details id="legend-panel" class="panel accordion">
            <summary>Filters & overlays <span class="accordion-hint"></span></summary>
            <div class="accordion-content">
                <div id="size-filter-container"></div>

                <label class="select-label">
                    Containment level
                    <select id="containment-filter">
                        <option value="all">All containment levels</option>
                        <option value="low">Under 25%</option>
                        <option value="medium">25%-75%</option>
                        <option value="high">Over 75%</option>
                        <option value="contained">Fully contained</option>
                    </select>
                </label>

                <label class="toggle">
                    <input type="checkbox" id="aq-toggle" />
                    <span>Show air-quality overlay</span>
                </label>
            </div>
        </details>

        <details id="timeline-panel" class="panel accordion">
            <summary>Timeline <span class="accordion-hint"></span></summary>
            <div class="accordion-content">
                <div class="timeline-status">Showing fires through <output id="timeline-label">Loading…</output></div>
                <div class="timeline-range">
                    <input type="range" id="timeline-range" min="0" max="0" step="1" value="0" />
                </div>
                <p class="timeline-footnote">Drag to show fires discovered up to the selected date.</p>
            </div>
        </details>
    </div>

    <script src="https://api.mapbox.com/mapbox-gl-js/v3.1.2/mapbox-gl.js"></script>
    <script>
        (() => {
            // ============================================================
            // COLORADO-SPECIFIC CONFIGURATION
            // ============================================================
            const STATE_NAME = 'Colorado';
            const STATE_ABBREV = 'CO';
            // Colorado bounding box: SW corner to NE corner (with padding for context)
            const STATE_BOUNDS = [
                [-109.5, 36.8],  // Southwest: Four Corners area
                [-101.8, 41.2]   // Northeast: Nebraska border
            ];
            // Expanded bounds to prevent panning too far outside the state
            const MAX_BOUNDS = [
                [-112.0, 34.0],  // Southwest limit
                [-99.0, 44.0]    // Northeast limit
            ];
            const STATE_CENTER = [-105.5, 39.0];  // Roughly Denver area
            const STATE_ZOOM = 6;
            // ============================================================

            const MAPBOX_TOKEN = window.MAPBOX_ACCESS_TOKEN || document.body.dataset.mapboxToken || '';
            const DATAWRAPPER_CHART_ID = document.body.dataset.datawrapperChart || '';
            const TOP_FIRE_LIMIT = Number(document.body.dataset.topFires || 5);
            // NIFC ArcGIS endpoints - perimeters (polygons) and incident locations (points)
            const PERIMETERS_ENDPOINT = `https://services3.arcgis.com/T4QMspbfLg3qTGWY/arcgis/rest/services/WFIGS_Interagency_Perimeters_Current/FeatureServer/0/query?where=attr_POOState%3D%27US-${STATE_ABBREV}%27&outFields=*&f=geojson`;
            const INCIDENTS_ENDPOINT = `https://services3.arcgis.com/T4QMspbfLg3qTGWY/arcgis/rest/services/WFIGS_Incident_Locations_Current/FeatureServer/0/query?where=POOState%3D%27US-${STATE_ABBREV}%27&outFields=*&f=geojson`;
            const DAY_MS = 86_400_000;
            const SIZE_BUCKETS = [
                { id: 'mega', label: 'Mega • 100k+ acres', min: 100_000, max: null, color: '#ff4d4f' },
                { id: 'major', label: 'Major • 50k-100k', min: 50_000, max: 100_000, color: '#ff7648' },
                { id: 'large', label: 'Large • 10k-50k', min: 10_000, max: 50_000, color: '#ffa347' },
                { id: 'medium', label: 'Medium • 1k-10k', min: 1_000, max: 10_000, color: '#ffd257' },
                { id: 'small', label: 'Small • under 1k', min: 0, max: 1_000, color: '#fef2a1' }
            ];
            const BUCKET_MAP = new Map(SIZE_BUCKETS.map((bucket) => [bucket.id, bucket]));
            const SMALL_FIRE_ACRES = 3_000;
            const MAPBOX_STYLES = {
                terrain: 'mapbox://styles/evnwlg/cmilw81c000ii01r9b7lm9py5',
                satellite: 'mapbox://styles/mapbox/satellite-streets-v12'
            };
            const AQ_SOURCE_ID = 'aq-tiles';
            const AQ_LAYER_ID = 'aq-tiles-layer';
            const AQ_TILE_URL = 'https://tiles.aqicn.org/tiles/usepa-aqi/{z}/{x}/{y}.png?token=demo';

            const refs = {
                loading: document.getElementById('loading-overlay'),
                errorBanner: document.getElementById('error-banner'),
                lastUpdate: document.getElementById('last-update'),
                metricFires: document.getElementById('metric-fires'),
                metricAcres: document.getElementById('metric-acres'),
                metricContainment: document.getElementById('metric-containment'),
                topFiresList: document.getElementById('top-fires-list'),
                chartWrapper: document.getElementById('chart-wrapper'),
                chartFrame: document.getElementById('dw-chart'),
                sizeFilterContainer: document.getElementById('size-filter-container'),
                containmentFilter: document.getElementById('containment-filter'),
                airQualityToggle: document.getElementById('aq-toggle'),
                timelineRange: document.getElementById('timeline-range'),
                timelineLabel: document.getElementById('timeline-label'),
                styleButtons: document.querySelectorAll('.style-toggle button')
            };

            const state = {
                geojson: null,
                activeSizeBuckets: new Set(SIZE_BUCKETS.map((bucket) => bucket.id)),
                containmentFilter: 'all',
                timeline: { enabled: false, minTs: null, maxTs: null, currentTs: null },
                showAirQuality: false,
                baseStyle: 'terrain',
                featureLookup: new Map(),
                mapPadding: { top: 24, bottom: 24, left: 24, right: 320 }
            };

            if (!MAPBOX_TOKEN) {
                blockInitialization('Add a Mapbox access token by setting window.MAPBOX_ACCESS_TOKEN before loading this page.');
                return;
            }

            mapboxgl.accessToken = MAPBOX_TOKEN;
            const isMobile = window.matchMedia('(max-width: 640px)').matches;

            const map = new mapboxgl.Map({
                container: 'map',
                style: MAPBOX_STYLES[state.baseStyle],
                bounds: STATE_BOUNDS,
                fitBoundsOptions: { padding: 20 },
                maxBounds: MAX_BOUNDS,
                minZoom: 5,
                attributionControl: false
            });

            map.addControl(new mapboxgl.AttributionControl({ customAttribution: 'Fire perimeters © NIFC' }));
            map.addControl(new mapboxgl.NavigationControl(), 'top-left');
            map.addControl(new mapboxgl.FullscreenControl(), 'top-left');

            const hoverPopup = new mapboxgl.Popup({ closeButton: false, closeOnClick: false, className: 'hover-popup', offset: 8 });
            const clickPopup = new mapboxgl.Popup({ closeButton: true, anchor: 'top', maxWidth: '320px' });
            let interactionsBound = false;

            initializeStyleToggle();
            initializeSizeFilters();
            initializeContainmentFilter();
            initializeAirQualityToggle();
            initializeDatawrapperEmbed();
            initializeAccordionHints();

            map.on('load', async () => {
                try {
                    const geojson = await fetchAndMergeWildfireData();
                    enrichFeatureProperties(geojson);
                    state.geojson = geojson;
                    rebuildFeatureLookup();
                    initWildfireLayers();
                    updateStatsPanel();
                    initializeTimelineControls();
                    applyMapPadding();
                    refs.lastUpdate.textContent = `Data updated: ${new Date().toLocaleString('en-US', { dateStyle: 'medium', timeStyle: 'short' })}`;
                    refs.lastUpdate.hidden = false;
                    refs.errorBanner.hidden = true;
                } catch (error) {
                    console.error('Error loading wildfire data:', error);
                    showError(`Unable to load wildfire data: ${error.message}`);
                } finally {
                    refs.loading.classList.add('is-hidden');
                }
            });

            map.on('style.load', () => {
                if (state.geojson) {
                    initWildfireLayers();
                }
                if (state.showAirQuality) {
                    ensureAirQualityLayer();
                }
                applyMapPadding();
            });

            window.addEventListener('resize', () => {
                applyMapPadding();
            });

            function initializeStyleToggle() {
                refs.styleButtons.forEach((button) => {
                    button.addEventListener('click', () => {
                        const targetStyle = button.dataset.style;
                        if (!targetStyle || state.baseStyle === targetStyle) return;
                        state.baseStyle = targetStyle;
                        refs.styleButtons.forEach((btn) => btn.classList.toggle('active', btn === button));
                        map.setStyle(MAPBOX_STYLES[targetStyle]);
                    });
                });
            }

            function initializeSizeFilters() {
                SIZE_BUCKETS.forEach((bucket) => {
                    const label = document.createElement('label');
                    label.className = 'chip';

                    const input = document.createElement('input');
                    input.type = 'checkbox';
                    input.value = bucket.id;
                    input.checked = true;

                    const content = document.createElement('span');
                    content.className = 'chip-content';

                    const swatch = document.createElement('span');
                    swatch.className = 'chip-swatch';
                    swatch.style.background = bucket.color;

                    const text = document.createElement('span');
                    text.textContent = bucket.label;

                    content.append(swatch, text);
                    label.append(input, content);
                    refs.sizeFilterContainer.append(label);

                    input.addEventListener('change', () => {
                        if (input.checked) {
                            state.activeSizeBuckets.add(bucket.id);
                        } else {
                            state.activeSizeBuckets.delete(bucket.id);
                        }
                        updateMapFilters();
                    });
                });
            }

            function initializeContainmentFilter() {
                refs.containmentFilter.addEventListener('change', (event) => {
                    state.containmentFilter = event.target.value;
                    updateMapFilters();
                });
            }

            function initializeAirQualityToggle() {
                refs.airQualityToggle.addEventListener('change', (event) => {
                    state.showAirQuality = event.target.checked;
                    if (state.showAirQuality) {
                        ensureAirQualityLayer();
                    } else if (map.getLayer(AQ_LAYER_ID)) {
                        map.setLayoutProperty(AQ_LAYER_ID, 'visibility', 'none');
                    }
                });
            }

            function initializeDatawrapperEmbed() {
                if (!DATAWRAPPER_CHART_ID) {
                    refs.chartWrapper.hidden = true;
                    return;
                }
                refs.chartWrapper.hidden = false;
                refs.chartFrame.src = `https://datawrapper.dwcdn.net/${DATAWRAPPER_CHART_ID}/1/`;
            }

            function initializeAccordionHints() {
                document.querySelectorAll('.accordion').forEach((accordion) => {
                    const hint = accordion.querySelector('.accordion-hint');
                    if (!hint) return;
                    const sync = () => {
                        hint.textContent = accordion.open ? 'Hide' : 'Show';
                    };
                    sync();
                    accordion.addEventListener('toggle', sync);
                });
            }

            async function fetchAndMergeWildfireData() {
                // Fetch both perimeters (polygons) and incident points in parallel
                const [perimetersRes, incidentsRes] = await Promise.all([
                    fetch(PERIMETERS_ENDPOINT, { headers: { Accept: 'application/json' } }),
                    fetch(INCIDENTS_ENDPOINT, { headers: { Accept: 'application/json' } })
                ]);

                if (!perimetersRes.ok) {
                    throw new Error(`Perimeters: ${perimetersRes.status} ${perimetersRes.statusText}`);
                }
                if (!incidentsRes.ok) {
                    throw new Error(`Incidents: ${incidentsRes.status} ${incidentsRes.statusText}`);
                }

                const perimeters = await perimetersRes.json();
                const incidents = await incidentsRes.json();

                // Build a set of incident names that have perimeters
                const perimeterNames = new Set(
                    perimeters.features.map(f => 
                        (f.properties.poly_IncidentName || '').toLowerCase().trim()
                    ).filter(Boolean)
                );

                console.log(`Perimeters: ${perimeters.features.length}, Incident points: ${incidents.features.length}`);
                console.log('Perimeter names:', [...perimeterNames]);

                // Mark all perimeter features as NOT points (use string for reliable filter matching)
                perimeters.features.forEach(f => {
                    f.properties.__featureType = 'polygon';
                });

                // Add incident points that DON'T have perimeters (avoid duplicates)
                const pointsWithoutPerimeters = incidents.features.filter(f => {
                    const name = (f.properties.IncidentName || '').toLowerCase().trim();
                    return !perimeterNames.has(name);
                });

                console.log(`Points without perimeters: ${pointsWithoutPerimeters.length}`);

                // Normalize incident point properties to match perimeter schema
                pointsWithoutPerimeters.forEach(f => {
                    const props = f.properties;
                    // Map incident fields to perimeter-style fields
                    props.poly_IncidentName = props.IncidentName;
                    props.poly_GISAcres = props.DailyAcres || props.CalculatedAcres || props.IncidentSize || 0;
                    props.attr_PercentContained = props.PercentContained;
                    props.attr_FireCause = props.FireCause;
                    props.attr_POOState = props.POOState;
                    props.attr_POOCounty = props.POOCounty;
                    props.__featureType = 'point'; // Flag for rendering as point
                });

                // Combine: perimeters first, then points without perimeters
                const combined = {
                    type: 'FeatureCollection',
                    features: [...perimeters.features, ...pointsWithoutPerimeters]
                };

                console.log(`Combined total: ${combined.features.length} fires`);
                return combined;
            }

            function enrichFeatureProperties(geojson) {
                geojson.features.forEach((feature) => {
                    const props = feature.properties || {};
                    const acres = Number.parseFloat(props.poly_GISAcres) || 0;
                    const containment = Number.parseFloat(props.attr_PercentContained);
                    props.__acres = acres;
                    props.__containment = Number.isFinite(containment) ? containment : null;
                    props.__discoveryTs = parseTimestamp(props);
                    props.__primaryName = props.poly_IncidentName || props.attr_IncidentName || 'Unnamed fire';
                    props.__centroid = computeCentroid(feature.geometry);
                    props.__bounds = computeBounds(feature.geometry);
                    feature.properties = props;
                });
            }

            function rebuildFeatureLookup() {
                state.featureLookup.clear();
                state.geojson?.features.forEach((feature) => {
                    const key = feature.properties.__primaryName?.toLowerCase();
                    if (key) {
                        state.featureLookup.set(key, feature);
                    }
                });
            }

            function parseTimestamp(props) {
                const candidateFields = [
                    'attr_CreatedOnDateTime_dt',
                    'attr_DateCurrent',
                    'attr_ModifiedOnDateTime_dt',
                    'attr_IrwinReportDate',
                    'attr_FireDiscoveryDateTime'
                ];
                for (const field of candidateFields) {
                    const value = props[field];
                    if (!value) continue;
                    const ts =
                        typeof value === 'number'
                            ? value
                            : Number.isFinite(Number(value))
                                ? Number(value)
                                : Date.parse(value);
                    if (!Number.isNaN(ts)) {
                        return ts;
                    }
                }
                return null;
            }

            function computeCentroid(geometry) {
                if (!geometry) return null;
                
                // Handle Point geometry directly
                if (geometry.type === 'Point') {
                    const [lng, lat] = geometry.coordinates || [];
                    return (lng !== undefined && lat !== undefined) ? { lng, lat } : null;
                }
                
                // Handle Polygon/MultiPolygon
                let coords = [];
                if (geometry.type === 'Polygon') {
                    coords = geometry.coordinates?.[0] || [];
                } else if (geometry.type === 'MultiPolygon') {
                    coords = geometry.coordinates?.[0]?.[0] || [];
                }
                if (!coords.length) return null;
                let sumLng = 0;
                let sumLat = 0;
                coords.forEach(([lng, lat]) => {
                    sumLng += lng;
                    sumLat += lat;
                });
                const count = coords.length;
                return count ? { lng: sumLng / count, lat: sumLat / count } : null;
            }

            function computeBounds(geometry) {
                if (!geometry) return null;
                let coords = [];
                if (geometry.type === 'Polygon') {
                    coords = geometry.coordinates?.[0] || [];
                } else if (geometry.type === 'MultiPolygon') {
                    geometry.coordinates?.forEach((poly) => {
                        poly?.[0]?.forEach((c) => coords.push(c));
                    });
                }
                if (!coords.length) return null;
                let minLng = Infinity;
                let maxLng = -Infinity;
                let minLat = Infinity;
                let maxLat = -Infinity;
                coords.forEach(([lng, lat]) => {
                    if (lng < minLng) minLng = lng;
                    if (lng > maxLng) maxLng = lng;
                    if (lat < minLat) minLat = lat;
                    if (lat > maxLat) maxLat = lat;
                });
                if (!isFinite(minLng) || !isFinite(minLat) || !isFinite(maxLng) || !isFinite(maxLat)) {
                    return null;
                }
                return [
                    [minLng, minLat],
                    [maxLng, maxLat]
                ];
            }

            function initWildfireLayers() {
                if (!state.geojson) return;
                const acresExpr = ['coalesce', ['to-number', ['get', '__acres']], 0];
                // Filter for polygon features (perimeters) vs point features (incidents without perimeters)
                const isPolygon = ['any', 
                    ['==', ['geometry-type'], 'Polygon'],
                    ['==', ['geometry-type'], 'MultiPolygon']
                ];
                const isPoint = ['==', ['geometry-type'], 'Point'];

                if (!map.getSource('wildfires')) {
                    map.addSource('wildfires', { type: 'geojson', data: state.geojson });
                    
                    // === POLYGON LAYERS (fire perimeters) ===
                    
                    // 1. Symbol for small polygon fires (Zoom < 8)
                    map.addLayer({
                        id: 'wildfire-small-symbol',
                        type: 'symbol',
                        source: 'wildfires',
                        filter: ['all', isPolygon, ['<', acresExpr, SMALL_FIRE_ACRES]],
                        maxzoom: 8,
                        layout: {
                            'text-field': '×',
                            'text-font': ['Arial Unicode MS Bold'],
                            'text-size': 28,
                            'text-allow-overlap': true,
                            'text-ignore-placement': true
                        },
                        paint: {
                            'text-color': '#ff8c42',
                            'text-halo-color': '#b11226',
                            'text-halo-width': 2
                        }
                    });

                    // 2. Fill for LARGE polygon fires (Always visible)
                    map.addLayer({
                        id: 'wildfire-fill-large',
                        type: 'fill',
                        source: 'wildfires',
                        filter: ['all', isPolygon, ['>=', acresExpr, SMALL_FIRE_ACRES]],
                        paint: {
                            'fill-color': '#ff8c42',
                            'fill-opacity': 0.6
                        }
                    }, 'wildfire-small-symbol');

                    // 3. Fill for SMALL polygon fires (Zoom >= 8 only)
                    map.addLayer({
                        id: 'wildfire-fill-small',
                        type: 'fill',
                        source: 'wildfires',
                        filter: ['all', isPolygon, ['<', acresExpr, SMALL_FIRE_ACRES]],
                        minzoom: 8,
                        paint: {
                            'fill-color': '#ff8c42',
                            'fill-opacity': 0.6
                        }
                    }, 'wildfire-small-symbol');

                    // 4. Outline for LARGE polygon fires (Always visible)
                    map.addLayer({
                        id: 'wildfire-outline-large',
                        type: 'line',
                        source: 'wildfires',
                        filter: ['all', isPolygon, ['>=', acresExpr, SMALL_FIRE_ACRES]],
                        paint: {
                            'line-color': '#b11226',
                            'line-width': 1.5,
                            'line-opacity': 0.9
                        }
                    });

                    // 5. Outline for SMALL polygon fires (Zoom >= 8 only)
                    map.addLayer({
                        id: 'wildfire-outline-small',
                        type: 'line',
                        source: 'wildfires',
                        filter: ['all', isPolygon, ['<', acresExpr, SMALL_FIRE_ACRES]],
                        minzoom: 8,
                        paint: {
                            'line-color': '#b11226',
                            'line-width': 1.5,
                            'line-opacity': 0.9
                        }
                    });

                    // === POINT LAYERS (incidents without perimeters) ===
                    // Only show features with __featureType='point' (incident points without perimeters)
                    const pointLayerFilter = ['==', ['get', '__featureType'], 'point'];
                    
                    // X symbol for point incidents (same style as small polygon fires)
                    map.addLayer({
                        id: 'wildfire-point-symbol',
                        type: 'symbol',
                        source: 'wildfires',
                        filter: pointLayerFilter,
                        layout: {
                            'text-field': '×',
                            'text-font': ['Arial Unicode MS Bold'],
                            'text-size': 28,
                            'text-allow-overlap': true,
                            'text-ignore-placement': true
                        },
                        paint: {
                            'text-color': '#ff8c42',
                            'text-halo-color': '#b11226',
                            'text-halo-width': 2
                        }
                    });
                    
                } else {
                    map.getSource('wildfires').setData(state.geojson);
                }

                if (!interactionsBound) {
                    bindMapInteractions();
                    interactionsBound = true;
                }

                updateMapFilters();
            }

            function bindMapInteractions() {
                const clickableLayers = [
                    'wildfire-small-symbol',
                    'wildfire-fill-large',
                    'wildfire-fill-small',
                    'wildfire-point-symbol'
                ];

                // Global click handler - query all wildfire layers
                map.on('click', (e) => {
                    console.log('Map click at:', e.lngLat);
                    
                    // Query features at click point from wildfire layers
                    const features = map.queryRenderedFeatures(e.point, {
                        layers: clickableLayers.filter(layer => map.getLayer(layer))
                    });
                    
                    console.log('Found features:', features.length);
                    
                    if (features.length > 0) {
                        const feature = features[0];
                        console.log('Feature:', feature.properties.__primaryName);
                        showFirePopup(feature, e.lngLat);
                    }
                });

                // Cursor styling
                clickableLayers.forEach(layer => {
                    map.on('mouseenter', layer, () => {
                        map.getCanvas().style.cursor = 'pointer';
                    });
                    map.on('mouseleave', layer, () => {
                        map.getCanvas().style.cursor = '';
                    });
                });
            }

            function showFirePopup(feature, lngLat) {
                const props = feature.properties || {};
                console.log('Showing popup for:', props.__primaryName);
                clickPopup
                    .setLngLat(lngLat)
                    .setHTML(buildPopupHtml(props))
                    .addTo(map);
            }

            function buildPopupHtml(props) {
                const acres = props.__acres ? `${formatNumber(Math.round(props.__acres))} acres` : 'Acreage unavailable';
                const containment = Number.isFinite(props.__containment) ? `${Math.round(props.__containment)}% contained` : 'Containment unknown';
                const cause = props.attr_FireCause || 'Unknown';
                const location = props.attr_IncidentShortDescription ? props.attr_IncidentShortDescription : '';
                const isPointOnly = props.__featureType === 'point';

                return `
                <div class="popup">
                    <h3>${props.__primaryName}</h3>
                    <p class="popup-metric">${acres}</p>
                    <p class="popup-meta">${containment}</p>
                    <p class="popup-meta">Cause: ${cause}</p>
                    ${location ? `<p class="popup-meta">${location}</p>` : ''}
                    ${isPointOnly ? `<p class="popup-note">Perimeter data not available</p>` : ''}
                    <p class="popup-source">Source: <a href="https://data-nifc.opendata.arcgis.com/" target="_blank" rel="noopener">NIFC</a></p>
                </div>
                `;
            }

            function updateStatsPanel() {
                const features = state.geojson?.features || [];
                const totalFires = features.length;
                const totalAcres = features.reduce((sum, feature) => sum + (feature.properties.__acres || 0), 0);
                const validContainments = features
                    .map((feature) => feature.properties.__containment)
                    .filter((value) => Number.isFinite(value));
                const avgContainment = validContainments.length
                    ? validContainments.reduce((a, b) => a + b, 0) / validContainments.length
                    : null;

                refs.metricFires.textContent = totalFires ? formatNumber(totalFires) : '--';
                refs.metricAcres.textContent = totalAcres ? `${formatNumber(Math.round(totalAcres))}` : '--';
                refs.metricContainment.textContent = Number.isFinite(avgContainment)
                    ? `${Math.round(avgContainment)}%`
                    : '--';

                const sorted = [...features].sort((a, b) => (b.properties.__acres || 0) - (a.properties.__acres || 0));
                const top = sorted.slice(0, TOP_FIRE_LIMIT);
                refs.topFiresList.innerHTML = '';
                top.forEach((feature) => {
                    const props = feature.properties;
                    const li = document.createElement('li');
                    const bucket = getBucketForAcres(props.__acres);
                    const key = props.__primaryName?.toLowerCase();
                    if (key) {
                        li.dataset.fireKey = key;
                    }
                    li.innerHTML = `
                        <strong>${props.__primaryName}</strong>
                        <div class="fire-meta">${props.__acres ? `${formatNumber(Math.round(props.__acres))} acres` : 'Unknown size'} • ${
                        Number.isFinite(props.__containment) ? `${Math.round(props.__containment)}% contained` : 'Containment unknown'
                    }</div>
                    `;
                    if (bucket) {
                        li.style.setProperty('--bullet-color', bucket.color);
                        li.style.listStyle = 'none';
                        li.style.position = 'relative';
                        li.style.paddingLeft = '20px';
                        li.insertAdjacentHTML('afterbegin', '<span class="bullet"></span>');
                        const bullet = li.querySelector('.bullet');
                        bullet.style.position = 'absolute';
                        bullet.style.left = '0';
                        bullet.style.top = '0.6em';
                        bullet.style.width = '10px';
                        bullet.style.height = '10px';
                        bullet.style.borderRadius = '50%';
                        bullet.style.background = bucket.color;
                    }
                    refs.topFiresList.append(li);
                });
                attachTopFireHandlers();
            }

            function getBucketForAcres(acres = 0) {
                return SIZE_BUCKETS.find((bucket) => acres >= bucket.min && (bucket.max === null || acres < bucket.max)) || null;
            }

            function attachTopFireHandlers() {
                refs.topFiresList.querySelectorAll('li').forEach((li) => {
                    li.addEventListener('click', () => {
                        const key = li.dataset.fireKey;
                        if (!key) return;
                        const feature = state.featureLookup.get(key);
                        if (!feature) return;
                        focusFeature(feature);
                    });
                });
            }

            function focusFeature(feature, options = {}) {
                try {
                    const bounds = feature.properties?.__bounds;
                    const centroid = feature.properties?.__centroid;
                    const padding = state.mapPadding || { top: 40, bottom: 40, left: 40, right: 40 };
                    // Use provided lngLat (click point) or centroid
                    const popupLocation = options.lngLat || (centroid ? [centroid.lng, centroid.lat] : null);

                    if (bounds) {
                        map.fitBounds(bounds, {
                            padding: { ...padding, right: padding.right + 60 },
                            maxZoom: 11,
                            duration: 1000
                        });
                    } else if (centroid) {
                        map.flyTo({ center: [centroid.lng, centroid.lat], zoom: 8, essential: true });
                    }

                    if (popupLocation) {
                        clickPopup.setLngLat(popupLocation).setHTML(buildPopupHtml(feature.properties)).addTo(map);
                    }
                } catch (err) {
                    console.error('Focus failed:', err);
                }
            }

            function initializeTimelineControls() {
                const timestamps = (state.geojson?.features || [])
                    .map((feature) => feature.properties.__discoveryTs)
                    .filter((ts) => Number.isFinite(ts));

                if (!timestamps.length) {
                    refs.timelineRange.disabled = true;
                    refs.timelineLabel.textContent = 'Timeline unavailable';
                    state.timeline.enabled = false;
                    return;
                }

                const minTs = Math.min(...timestamps);
                const maxTs = Math.max(...timestamps);
                const totalDays = Math.max(0, Math.round((maxTs - minTs) / DAY_MS));

                refs.timelineRange.min = 0;
                refs.timelineRange.max = totalDays || 1;
                refs.timelineRange.value = totalDays;
                state.timeline = { enabled: true, minTs, maxTs, currentTs: maxTs };
                updateTimelineLabel(maxTs);

                refs.timelineRange.addEventListener('input', () => {
                    const offsetDays = Number(refs.timelineRange.value);
                    const ts = state.timeline.minTs + offsetDays * DAY_MS;
                    state.timeline.currentTs = ts;
                    updateTimelineLabel(ts);
                    updateMapFilters();
                });
            }

            function updateTimelineLabel(ts) {
                refs.timelineLabel.textContent = new Date(ts).toLocaleDateString('en-US', {
                    month: 'short',
                    day: 'numeric',
                    year: 'numeric'
                });
            }

            function ensureAirQualityLayer() {
                if (!map.getSource(AQ_SOURCE_ID)) {
                    map.addSource(AQ_SOURCE_ID, {
                        type: 'raster',
                        tiles: [AQ_TILE_URL],
                        tileSize: 256,
                        attribution: 'Air quality overlay © aqicn.org (demo token)'
                    });
                }
                if (!map.getLayer(AQ_LAYER_ID)) {
                    const beforeId = map.getLayer('wildfire-fill') ? 'wildfire-fill' : undefined;
                    map.addLayer(
                        {
                            id: AQ_LAYER_ID,
                            type: 'raster',
                            source: AQ_SOURCE_ID,
                            paint: { 'raster-opacity': 0.28 }
                        },
                        beforeId
                    );
                } else {
                    map.setLayoutProperty(AQ_LAYER_ID, 'visibility', 'visible');
                }
            }

            function updateMapFilters() {
                // Check for actual layer names
                if (!map.getLayer('wildfire-fill-large')) return;

                const acresExpr = ['coalesce', ['to-number', ['get', '__acres']], 0];
                const isPolygon = ['any', 
                    ['==', ['geometry-type'], 'Polygon'],
                    ['==', ['geometry-type'], 'MultiPolygon']
                ];
                const isPoint = ['==', ['get', '__featureType'], 'point'];
                
                const baseFilters = ['all'];
                const sizeFilter = buildSizeFilterExpression();
                const containmentFilter = buildContainmentFilterExpression();
                const timelineFilter = buildTimelineFilterExpression();

                if (sizeFilter) baseFilters.push(sizeFilter);
                if (containmentFilter) baseFilters.push(containmentFilter);
                if (timelineFilter) baseFilters.push(timelineFilter);

                // Polygon layers: Large fires (>= SMALL_FIRE_ACRES)
                const largePolyFilter = ['all', isPolygon, ...baseFilters.slice(1), ['>=', acresExpr, SMALL_FIRE_ACRES]];
                // Polygon layers: Small fires (< SMALL_FIRE_ACRES)
                const smallPolyFilter = ['all', isPolygon, ...baseFilters.slice(1), ['<', acresExpr, SMALL_FIRE_ACRES]];
                // Point layers - must have __featureType='point'
                const pointFilter = ['all', isPoint, ...baseFilters.slice(1)];

                map.setFilter('wildfire-fill-large', largePolyFilter);
                map.setFilter('wildfire-outline-large', largePolyFilter);
                map.setFilter('wildfire-fill-small', smallPolyFilter);
                map.setFilter('wildfire-outline-small', smallPolyFilter);
                map.setFilter('wildfire-small-symbol', smallPolyFilter);
                
                // Point layers
                if (map.getLayer('wildfire-point-symbol')) {
                    map.setFilter('wildfire-point-symbol', pointFilter);
                }
            }

            function buildSizeFilterExpression() {
                if (state.activeSizeBuckets.size === 0) {
                    return ['==', 1, 0];
                }
                if (state.activeSizeBuckets.size === SIZE_BUCKETS.length) {
                    return null;
                }
                const acresExpr = ['coalesce', ['to-number', ['get', '__acres']], 0];
                const anyExpr = ['any'];
                state.activeSizeBuckets.forEach((bucketId) => {
                    const bucket = BUCKET_MAP.get(bucketId);
                    if (!bucket) return;
                    const clauses = ['all', ['>=', acresExpr, bucket.min]];
                    if (bucket.max !== null) {
                        clauses.push(['<', acresExpr, bucket.max]);
                    }
                    anyExpr.push(clauses);
                });
                return anyExpr.length > 1 ? anyExpr : null;
            }

            function buildContainmentFilterExpression() {
                const containmentExpr = ['coalesce', ['to-number', ['get', '__containment']], -1];
                switch (state.containmentFilter) {
                    case 'low':
                        return ['<', containmentExpr, 25];
                    case 'medium':
                        return ['all', ['>=', containmentExpr, 25], ['<', containmentExpr, 75]];
                    case 'high':
                        return ['>=', containmentExpr, 75];
                    case 'contained':
                        return ['>=', containmentExpr, 100];
                    default:
                        return null;
                }
            }

            function buildTimelineFilterExpression() {
                if (!state.timeline.enabled || !Number.isFinite(state.timeline.currentTs)) {
                    return null;
                }
                const discoveryExpr = ['coalesce', ['to-number', ['get', '__discoveryTs']], -1];
                return ['any', ['==', discoveryExpr, -1], ['<=', discoveryExpr, state.timeline.currentTs]];
            }

            function blockInitialization(message) {
                refs.loading.classList.add('is-hidden');
                showError(message);
            }

            function showError(message) {
                refs.errorBanner.textContent = `⚠️ ${message}`;
                refs.errorBanner.hidden = false;
            }

            function formatNumber(value) {
                return new Intl.NumberFormat('en-US').format(value);
            }

            function applyMapPadding() {
                if (!map) return;
                // Symmetric padding - no asymmetric shift
                state.mapPadding = {
                    top: 20,
                    bottom: 20,
                    left: 20,
                    right: 20
                };
                map.setPadding(state.mapPadding);
            }
        })();
    </script>
    <script>
        window.addEventListener('message', (event) => {
            if (event.data['datawrapper-height']) {
                for (const [chartId, height] of Object.entries(event.data['datawrapper-height'])) {
                    const iframe = document.querySelector(`iframe[src*="${chartId}"]`);
                    if (iframe) {
                        iframe.style.height = `${height}px`;
                    }
                }
            }
        });
    </script>
</body>

</html>

